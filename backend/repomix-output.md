This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-30T05:05:21.760Z

# File Summary

## Purpose
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

## Additional Info

# Directory Structure
```
apps/
  authorization/
    migrations/
      0001_initial.py
      0002_alter_user_managers.py
    admin.py
    apps.py
    models.py
    tests.py
    urls.py
    views.py
  engine/
    admin.py
    apps.py
    models.py
    pool.py
    tasks.py
    tests.py
    urls.py
    views.py
  market_data/
    migrations/
      0001_initial.py
      0002_stockdata_stock_name.py
      0003_stockdata_isetf.py
      0004_stockdata_search_vector_and_more.py
      0005_auto_20250123_0604.py
      0006_remove_stockdata_market_data_search__f0d0dd_gin_and_more.py
    admin.py
    apps.py
    models.py
    serializers.py
    tests.py
    urls.py
    utils.py
    views.py
  strategy/
    migrations/
      0001_initial.py
    admin.py
    apps.py
    models.py
    serializers.py
    tests.py
    urls.py
    views.py
  Authentication.py
config/
  asgi.py
  celery.py
  settings.py
  urls.py
  wsgi.py
docker/
  sandbox/
    Dockerfile
    entrypoint.sh
    execute.py
    requirements.txt
.dockerignore
.env.example
.gitignore
entrypoint.sh
manage.py
README.md
requirements.txt
```

# Files

## File: apps/authorization/migrations/0001_initial.py
```python
# Generated by Django 5.1.4 on 2025-01-14 19:14

import django.contrib.auth.models
import django.utils.timezone
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('auth', '0012_alter_user_first_name_max_length'),
    ]

    operations = [
        migrations.CreateModel(
            name='User',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('password', models.CharField(max_length=128, verbose_name='password')),
                ('last_login', models.DateTimeField(blank=True, null=True, verbose_name='last login')),
                ('is_superuser', models.BooleanField(default=False, help_text='Designates that this user has all permissions without explicitly assigning them.', verbose_name='superuser status')),
                ('first_name', models.CharField(blank=True, max_length=150, verbose_name='first name')),
                ('last_name', models.CharField(blank=True, max_length=150, verbose_name='last name')),
                ('is_staff', models.BooleanField(default=False, help_text='Designates whether the user can log into this admin site.', verbose_name='staff status')),
                ('is_active', models.BooleanField(default=True, help_text='Designates whether this user should be treated as active. Unselect this instead of deleting accounts.', verbose_name='active')),
                ('date_joined', models.DateTimeField(default=django.utils.timezone.now, verbose_name='date joined')),
                ('username', models.CharField(blank=True, max_length=255)),
                ('email', models.EmailField(max_length=254, unique=True)),
                ('profile_pictue', models.URLField(blank=True, null=True)),
                ('groups', models.ManyToManyField(blank=True, help_text='The groups this user belongs to. A user will get all permissions granted to each of their groups.', related_name='user_set', related_query_name='user', to='auth.group', verbose_name='groups')),
                ('user_permissions', models.ManyToManyField(blank=True, help_text='Specific permissions for this user.', related_name='user_set', related_query_name='user', to='auth.permission', verbose_name='user permissions')),
            ],
            options={
                'verbose_name': 'user',
                'verbose_name_plural': 'users',
                'abstract': False,
            },
            managers=[
                ('objects', django.contrib.auth.models.UserManager()),
            ],
        ),
    ]
```

## File: apps/authorization/migrations/0002_alter_user_managers.py
```python
# Generated by Django 5.1.4 on 2025-01-22 04:13

from django.db import migrations


class Migration(migrations.Migration):

    dependencies = [
        ('authorization', '0001_initial'),
    ]

    operations = [
        migrations.AlterModelManagers(
            name='user',
            managers=[
            ],
        ),
    ]
```

## File: apps/authorization/admin.py
```python
from django.contrib import admin
from .models import User

# Register your models here.
admin.site.register(User)
```

## File: apps/authorization/apps.py
```python
from django.apps import AppConfig


class AuthorizationConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.authorization'
    label = 'authorization'
```

## File: apps/authorization/models.py
```python
from django.db import models
from django.contrib.auth.models import AbstractUser,BaseUserManager

class UserManager(BaseUserManager):
    def create_user(self, email, password=None, **extra_fields):
        if not email:
            raise ValueError('The Email field must be set')
        email = self.normalize_email(email)
        user = self.model(email=email, **extra_fields)
        user.set_password(password)
        user.save(using=self._db)
        return user

    def create_superuser(self, email, password=None, **extra_fields):
        extra_fields.setdefault('is_staff', True)
        extra_fields.setdefault('is_superuser', True)

        if extra_fields.get('is_staff') is not True:
            raise ValueError('Superuser must have is_staff=True.')
        if extra_fields.get('is_superuser') is not True:
            raise ValueError('Superuser must have is_superuser=True.')

        return self.create_user(email, password, **extra_fields)

class User(AbstractUser):
    username=models.CharField(max_length=255,blank=True)
    email=models.EmailField(unique=True)
    profile_pictue=models.URLField(blank=True,null=True)

    # django by default uses username as the unqiue identfier
    # we want to use email as the unique identifier
    USERNAME_FIELD = 'email' 
    REQUIRED_FIELDS = []

    objects = UserManager()

    def __str__(self):
        return self.email
```

## File: apps/authorization/tests.py
```python
from django.test import TestCase

# Create your tests here.
```

## File: apps/authorization/urls.py
```python
from django.urls import path
from .views import  CreateUserView, TestView

app_name="apps.authorization"
urlpatterns = [
    # path('google-login/', GoogleLoginView.as_view(), name='google-login'),
    # path('refresh-token/', TokenRefreshCookieView.as_view(), name='refresh-token'),
    path('create-user/',CreateUserView.as_view(),name='create-user'),
    path('test/',TestView.as_view(),name='test')
]
```

## File: apps/authorization/views.py
```python
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from google.oauth2 import id_token
from google.auth.transport import requests
from django.conf import settings
from django.contrib.auth import get_user_model
from rest_framework.authentication import BaseAuthentication
from rest_framework.exceptions import AuthenticationFailed


User = get_user_model()


class ValidateGoogleToken(BaseAuthentication):
    def authenticate(self, request):
        auth_header = request.headers.get('Authorization')
        if not auth_header or not auth_header.startswith('Bearer '):
            return None

        token = auth_header.split(' ')[1]
        try:
            idinfo = id_token.verify_oauth2_token(
                token, 
                requests.Request(), 
                settings.GOOGLE_CLIENT_ID
            )
            print(idinfo)
            verified_email = idinfo['email']
            name = idinfo['name']
            print(f"initialising session for user with email {verified_email} and name {name}")
            user, _ = User.objects.get_or_create(email=verified_email,username=name)
            return (user, None)
        except Exception as e:
            raise AuthenticationFailed(f'Invalid token: {str(e)}')

class CreateUserView(APIView):

    authentication_classes = [ValidateGoogleToken]
    permission_classes = []

    def post(self, request):
        user = request.user
        print(f"user from creste user view: {user} && {user.username}")
        if not user.email:
            return Response({"error": "Email is required"}, status=status.HTTP_400_BAD_REQUEST)            
        return Response({"message": "Success"}, status=status.HTTP_200_OK)

class TestView(APIView):
    def post(self, request):
        print(request.user)
        return Response({"message": "Success"}, status=status.HTTP_200_OK)
```

## File: apps/engine/admin.py
```python
from django.contrib import admin

# Register your models here.
```

## File: apps/engine/apps.py
```python
from django.apps import AppConfig


class EngineConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.engine'
```

## File: apps/engine/models.py
```python
from django.db import models

# Create your models here.
```

## File: apps/engine/pool.py
```python
import tempfile
import os
from queue import Queue
from threading import Lock
import docker
import logging
import json

logger = logging.getLogger(__name__)

class ContainerPool:
    _instance = None
    _lock = Lock()
    _active_containers = set()

    def __new__(cls, *args, **kwargs):
        if not cls._instance:
            with cls._lock:
                if not cls._instance:
                    cls._instance = super(ContainerPool, cls).__new__(cls, *args, **kwargs)
                    cls._instance._initialize()
        return cls._instance

    def _initialize(self):
        self.client = docker.from_env()
        self.pool = Queue(maxsize=2)
        self.lock = Lock()
        self.temp_dir_dict = {}
        self._init_pool()

    def _init_pool(self):
        for _ in range(2):
            tmpfs_path = self._create_tmpfs()
            container = self._create_container(tmpfs_path)
            self.temp_dir_dict[container.id] = tmpfs_path
            logger.info("New container created with tmpfs mounted")
            self.pool.put(container)

    def _create_tmpfs(self):
        tmpfs_path = tempfile.mkdtemp(prefix="container_tmpfs_")
        with self.lock:
            os.system(f"mount -t tmpfs -o size=64m tmpfs {tmpfs_path}")
        logger.info(f"Temporary filesystem created at {tmpfs_path}")
        return tmpfs_path

    def _create_container(self, tmpfs_path):
        try:
            container = self.client.containers.run(
                'code-sandbox',
                detach=True,
                network='backend',
                mem_limit='256m',
                read_only=True,
                tmpfs={'/tmp': 'rw,noexec,nosuid,size=64M'},
                volumes={tmpfs_path: {'bind': '/host_tmpfs', 'mode': 'ro'}}
            )
            return container
        except Exception as e:
            logger.error(f"Failed to create container: {e}")
            self._cleanup_tmpfs(tmpfs_path)
            raise

    def acquire_container(self):
        with self.lock:
            container = self.pool.get(block=True, timeout=30)
            container_info_json = json.dumps(container.attrs)
            print(f"container infor {container_info_json}")
            self._active_containers.add(container.id)
            temp_dir = self.temp_dir_dict[container.id]
            logger.info(f"Container {container.id} acquired")
            return container, temp_dir

    def release_container(self, container):
        try:
            temp_dir = self.temp_dir_dict[container.id]
            self._clear_tmpfs(temp_dir)
            with self.lock:
                self._active_containers.remove(container.id)
                self.pool.put(container)
            logger.info(f"Container {container.id} released and tmpfs cleared")
        except Exception as e:
            logger.error(f"Failed to release container {container.id}: {e}")
            self._replace_container(container)

    def _clear_tmpfs(self, tmpfs_path):
        try:
            for filename in os.listdir(tmpfs_path):
                file_path = os.path.join(tmpfs_path, filename)
                if os.path.isfile(file_path) or os.path.islink(file_path):
                    os.unlink(file_path)
                elif os.path.isdir(file_path):
                    os.rmdir(file_path)
            logger.info(f"Cleared contents of tmpfs at {tmpfs_path}")
        except Exception as e:
            logger.error(f"Failed to clear tmpfs at {tmpfs_path}: {e}")

    def _replace_container(self, container):
        try:
            container.remove(force=True)
            logger.info(f"Container {container.id} removed")
        except docker.errors.NotFound:
            logger.warning(f"Container {container.id} not found during removal")
        except Exception as e:
            logger.error(f"Failed to remove container {container.id}: {e}")

        tmpfs_path = self.temp_dir_dict.pop(container.id, None)
        if tmpfs_path:
            self._cleanup_tmpfs(tmpfs_path)

        new_tmpfs_path = self._create_tmpfs()
        new_container = self._create_container(new_tmpfs_path)
        self.temp_dir_dict[new_container.id] = new_tmpfs_path

        with self.lock:
            self.pool.put(new_container)
        logger.info(f"Container {new_container.id} replaced with new tmpfs")

    def cleanup_all_containers(self):
        logger.info("Cleaning up all containers...")
        with self.lock:
            while not self.pool.empty():
                try:
                    container = self.pool.get_nowait()
                    self._remove_container(container)
                except Exception as e:
                    logger.error(f"Error removing container from pool: {e}")

            for container_id in list(self._active_containers):
                try:
                    container = self.client.containers.get(container_id)
                    self._remove_container(container)
                except Exception as e:
                    logger.error(f"Error removing active container {container_id}: {e}")

            self._active_containers.clear()
        logger.info("All containers and tmpfs mounts cleaned up")

    def _remove_container(self, container):
        try:
            container.remove(force=True)
            logger.info(f"Container {container.id} removed")
            tmpfs_path = self.temp_dir_dict.pop(container.id, None)
            if tmpfs_path:
                self._cleanup_tmpfs(tmpfs_path)
        except Exception as e:
            logger.error(f"Error removing container {container.id}: {e}")

    def _cleanup_tmpfs(self, tmpfs_path):
        try:
            os.system(f"umount {tmpfs_path}")
            os.rmdir(tmpfs_path)
            logger.info(f"Temporary filesystem at {tmpfs_path} unmounted and removed")
        except Exception as e:
            logger.error(f"Failed to clean up tmpfs at {tmpfs_path}: {e}")
```

## File: apps/engine/tasks.py
```python
from celery import shared_task
from .pool import ContainerPool
import docker
import os
import logging
import pickle
import pandas as pd
import requests 
import base64
from django.core.cache import cache
from io import StringIO


logger = logging.getLogger(__name__)

def serialize_df(df):
    return base64.b64encode(pickle.dumps(df)).decode('utf-8')

def deserialize_df(data_str):
    return pickle.loads(base64.b64decode(data_str.encode('utf-8')))

def fetch_data(name):
    cache_key = f"data_{name}"
    cached_data = cache.get(cache_key)

    if cached_data:
        logger.info(f"Using cached data for {name}")
        df =  deserialize_df(cached_data)
    else:
        logger.info("cache_miss")
        data_url = os.getenv("DATA_URL") + name + ".csv"
        try:
            response = requests.get(data_url)
            response.raise_for_status()
            df = pd.read_csv(StringIO(response.text))
            serialized_df = serialize_df(df)
            cache.set(cache_key, serialized_df, timeout=3600 * 24 * 7)

            
        except Exception as e:
            logger.error(f"Failed to fetch or cache data: {str(e)}")

    return df

def create_tar_archive(files):
    import tarfile
    import io

    tar_stream = io.BytesIO()
    with tarfile.open(fileobj=tar_stream, mode='w') as tar:
        for name, content in files.items():
            tarinfo = tarfile.TarInfo(name)
            tarinfo.size = len(content)
            tar.addfile(tarinfo, io.BytesIO(content))
    tar_stream.seek(0)
    return tar_stream.read()

@shared_task(bind=True, acks_late=True, queue='execution_queue')
def execute_code_task(self, backtest):
    pool=None
    if os.getenv("RUNTIME_CELERY","false").lower() == "true":
        logger.info(f'initialising the container')
        pool=ContainerPool()
    else:
        print("django env")

    if not isinstance(backtest, dict):
        logger.error("Invalid 'backtest' argument received.")
    
    name = backtest.get('name')
    logger.info(f"Extracted name: {name} (Type: {type(name)})")
    data_frame = fetch_data(name)
    container = None
    code = backtest.get('code')
    try:
        container ,temp_dir = pool.acquire_container()
        logger.info(f"Acquired container {container.id} with temp path {temp_dir}")

        code_path = os.path.join(temp_dir, "code.py")
        data_path = os.path.join(temp_dir, "data.pkl")

        with open(code_path, 'w') as code_file:
            code_file.write(code)
        with open(data_path, 'wb') as data_file:
            pickle.dump(data_frame, data_file)


        code_size = os.path.getsize(code_path)
        data_size = os.path.getsize(data_path)

        logger.info(f"Size of {code_path}: {code_size} bytes")
        logger.info(f"Size of {data_path}: {data_size} bytes")

        exec_result = container.exec_run(
            'python /app/execute.py',
            workdir='/host_tmpfs',
            demux=True
        )


        result = exec_result.output[0] if exec_result.output[0] else b''
        stderr = exec_result.output[1].decode() if exec_result.output[1] else ''

        logger.info(f"Raw stdout length: {len(result)} bytes")


        return {
            'exit_code': exec_result.exit_code,
            'stdout': result,
            'stderr': stderr,
        }
    except docker.errors.APIError as e:
        self.retry(exec=e, countdown=5, max_retries=3)
    finally:
        if container:
            pool.release_container(container)
```

## File: apps/engine/tests.py
```python
from django.test import TestCase

# Create your tests here.
```

## File: apps/engine/urls.py
```python
from django.urls import path
from .views import CodeExecutionView, HealthCheckView, TaskResultView

urlpatterns = [
    path('execute/', CodeExecutionView.as_view(), name='execute-code'),
    path('health/', HealthCheckView.as_view(), name='health-check'),
    path('task/<str:task_id>/', TaskResultView.as_view(), name='task-result'),
]
```

## File: apps/engine/views.py
```python
from django.shortcuts import render
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status, permissions
from .tasks import execute_code_task
from celery.result import AsyncResult
import logging
from redis.exceptions import ConnectionError
import redis
from celery.app.control import Control
from config.celery import app as celery_app

logger = logging.getLogger(__name__)

class ServiceStatus:
    @staticmethod
    def check_redis():
        try:
            r = redis.Redis(
                host='localhost',
                port=6379,
                db=0,
                socket_connect_timeout=2,
                socket_timeout=2
            )
            r.ping()
            return True, "Connected"
        except (redis.ConnectionError, ConnectionError) as e:
            return False, str(e)

    @staticmethod
    def celery_status():
        try:
            inspect = celery_app.control.inspect()
            active_workers = inspect.active()
            
            if active_workers is None:
                logger.error("No response from Celery workers")
                return False
            
            queues = inspect.active_queues()
            if not queues:
                logger.error("No active queues found")
                return False
            
            execution_queue_workers = any(
                'execution_queue' in worker_queues[0].get('name', '')
                for worker_queues in queues.values()
                if worker_queues
            )
            
            if not execution_queue_workers:
                logger.error("No workers found for execution_queue")
                return False
            
            logger.info(f"Celery status: Active workers found with execution_queue")
            return True
            
        except Exception as e:
            logger.error(f'Detailed Celery status check failed: {str(e)}', exc_info=True)
            return False

class HealthCheckView(APIView):
    authentication_classes = []
    permission_classes = [permissions.AllowAny]

    def get(self, request):
        services = {
            'redis': ServiceStatus.check_redis(),
            'celery': ServiceStatus.celery_status()
        }
        http_status = status.HTTP_200_OK if all(services.values()) else status.HTTP_503_SERVICE_UNAVAILABLE
        return Response(services, status=http_status)

class TaskResultView(APIView):
    authentication_classes = []
    permission_classes = [permissions.AllowAny]
    
    def get(self, request, task_id):
        try:
            result = AsyncResult(task_id, app=celery_app)
            
            if result.successful():
                return Response({
                    'status': 'completed',
                    'result': result.result
                })
            elif result.failed():
                return Response({
                    'status': 'error',
                    'error': str(result.result)
                }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
            return Response({
                'status': result.state.lower(),
                'eta': result.result.get('eta') if result.result else None
            })
            
        except Exception as e:
            logger.error(f"Error checking task status: {str(e)}")
            return Response({
                'error': f"Error checking task status: {str(e)}"
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

class CodeExecutionView(APIView):
    authentication_classes = []
    permission_classes = [permissions.AllowAny]
    
    def post(self, request):
        redis_status, redis_message = ServiceStatus.check_redis()
        celery_status = ServiceStatus.celery_status()
        
        if not redis_status or not celery_status:
            error_details = {
                'error': 'service unavailable',
                'redis_available': redis_status,
                'redis_message': redis_message if not redis_status else None,
                'celery_available': celery_status
            }
            logger.error(f"Service unavailable: {error_details}")
            return Response(error_details, status=status.HTTP_503_SERVICE_UNAVAILABLE)
            
        backtest = request.data.get('backtest')
        name = backtest.get("name")
        logger.info(f"backtest request recieved {name}")
        if not backtest:
            return Response({'error': 'missing code'}, status=status.HTTP_400_BAD_REQUEST)
            
        try:
            task = execute_code_task.apply_async(kwargs={"backtest": backtest}, queue='execution_queue')
            logger.info(f'task scheduled {task} on execution_queue')
            return Response({
                'task_id': task.id,
                'status_url': f'/engine/task/{task.id}/'
            }, status=status.HTTP_202_ACCEPTED)
            
        except Exception as e:
            logger.error(f'code submission failed: {str(e)}')
            return Response({'error': 'processing failed'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
```

## File: apps/market_data/migrations/0001_initial.py
```python
# Generated by Django 5.1.4 on 2025-01-13 19:34

from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='StockData',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('symbol', models.CharField(max_length=10, unique=True)),
                ('start_date', models.DateField(null=True)),
                ('latest_date', models.DateField(null=True)),
                ('source_file', models.CharField(max_length=255)),
            ],
        ),
    ]
```

## File: apps/market_data/migrations/0002_stockdata_stock_name.py
```python
# Generated by Django 5.1.4 on 2025-01-14 10:36

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('market_data', '0001_initial'),
    ]

    operations = [
        migrations.AddField(
            model_name='stockdata',
            name='stock_name',
            field=models.CharField(blank=True, null=True),
        ),
    ]
```

## File: apps/market_data/migrations/0003_stockdata_isetf.py
```python
# Generated by Django 5.1.4 on 2025-01-14 11:40

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('market_data', '0002_stockdata_stock_name'),
    ]

    operations = [
        migrations.AddField(
            model_name='stockdata',
            name='isEtf',
            field=models.BooleanField(default=False),
        ),
    ]
```

## File: apps/market_data/migrations/0004_stockdata_search_vector_and_more.py
```python
# Generated by Django 5.1.4 on 2025-01-22 04:00

import django.contrib.postgres.indexes
import django.contrib.postgres.search
from django.db import migrations


class Migration(migrations.Migration):

    dependencies = [
        ('market_data', '0003_stockdata_isetf'),
    ]

    operations = [
        migrations.AddField(
            model_name='stockdata',
            name='search_vector',
            field=django.contrib.postgres.search.SearchVectorField(blank=True, null=True),
        ),
        migrations.AddIndex(
            model_name='stockdata',
            index=django.contrib.postgres.indexes.GinIndex(fields=['search_vector'], name='market_data_search__f0d0dd_gin'),
        ),
    ]
```

## File: apps/market_data/migrations/0005_auto_20250123_0604.py
```python
# Generated by Django 5.1.4 on 2025-01-23 06:04

from django.db import migrations


class Migration(migrations.Migration):

    dependencies = [
        ('market_data', '0004_stockdata_search_vector_and_more'),
    ]

    operations = [
        migrations.RunSQL("CREATE EXTENSION IF NOT EXISTS pg_trgm;"),
    ]
```

## File: apps/market_data/migrations/0006_remove_stockdata_market_data_search__f0d0dd_gin_and_more.py
```python
# Generated by Django 5.1.4 on 2025-01-23 06:19

import django.contrib.postgres.indexes
from django.db import migrations


class Migration(migrations.Migration):

    dependencies = [
        ('market_data', '0005_auto_20250123_0604'),
    ]

    operations = [
        migrations.RemoveIndex(
            model_name='stockdata',
            name='market_data_search__f0d0dd_gin',
        ),
        migrations.RemoveField(
            model_name='stockdata',
            name='search_vector',
        ),
        migrations.AddIndex(
            model_name='stockdata',
            index=django.contrib.postgres.indexes.GinIndex(fields=['symbol'], name='stockdata_trgm_symbol_idx', opclasses=['gin_trgm_ops']),
        ),
        migrations.AddIndex(
            model_name='stockdata',
            index=django.contrib.postgres.indexes.GinIndex(fields=['stock_name'], name='stockdata_trgm_stock_name_idx', opclasses=['gin_trgm_ops']),
        ),
    ]
```

## File: apps/market_data/admin.py
```python
from django.contrib import admin
from .models import StockData
# Register your models here.

admin.site.register(StockData)
```

## File: apps/market_data/apps.py
```python
from django.apps import AppConfig


class MarketDataConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.market_data'
```

## File: apps/market_data/models.py
```python
from django.db import models
from django.contrib.postgres.indexes import GinIndex
from django.contrib.postgres.search import SearchVectorField
from django.contrib.postgres.search import SearchVector
# Create your models here.

class StockData(models.Model):
    symbol = models.CharField(max_length=10, unique=True)
    stock_name= models.CharField(null=True,blank=True)
    start_date = models.DateField(null=True)
    latest_date = models.DateField(null=True)
    isEtf = models.BooleanField(default=False)
    source_file = models.CharField(max_length=255)
    # search_vector = SearchVectorField(null=True,blank =True)

    class Meta:
        indexes = [ 
                    GinIndex(name="stockdata_trgm_symbol_idx", fields=["symbol"], opclasses=["gin_trgm_ops"]),
                    GinIndex(name="stockdata_trgm_stock_name_idx", fields=["stock_name"], opclasses=["gin_trgm_ops"])
                ] 


    def __str__(self):
        return f"{self.symbol} ({self.stock_name})"
```

## File: apps/market_data/serializers.py
```python
from rest_framework import serializers
from .models import StockData

class StockDataSerializer(serializers.ModelSerializer):
    class Meta:
        model = StockData
        fields = ['symbol', 'source_file', 'start_date', 'latest_date', 'stock_name', 'isEtf']
```

## File: apps/market_data/tests.py
```python
from django.test import TestCase

# Create your tests here.
```

## File: apps/market_data/urls.py
```python
from django.urls import path, include
from . import views
app_name="apps.market_data"
urlpatterns = [
    path('fetch-stock-data/',views.fetch_and_store_stock_data,name='fetch_stock_data'),
    path('search/',views.search,name='search')
]
```

## File: apps/market_data/utils.py
```python
import requests
import csv
from io import StringIO
from datetime import datetime

def prepare_dict(url,key_field,name_field,date_field,date_format):
    response = requests.get(url)
    response.raise_for_status()

    res_data =  response.text
    res_reader = csv.DictReader(StringIO(res_data))
    res_dict={row[key_field]:(row[name_field],normalize_date(row[date_field],date_format)) for row in res_reader}

    return res_dict
  


def prepare_list(url):
    commit_sha_response = requests.get(f"{url}/branches/main")
    commit_sha_response.raise_for_status()
    commit_sha = commit_sha_response.json()['commit']['sha']

    tree_sha_url = f"{url}/git/trees/{commit_sha}"
    tree_sha_response = requests.get(tree_sha_url)
    tree_sha_response.raise_for_status()
    tree = tree_sha_response.json()['tree']
    
    daily_url = ''
    for item in tree:
        if item['path'] == 'daily' and item['type'] == 'tree':
            daily_url = item['url']    
    if not daily_url:
        print("Error: 'daily' folder not found in repository tree")
        return []
    
    daily_data = requests.get(daily_url)
    daily_data.raise_for_status()
    daily_tree = daily_data.json()['tree']
    print(f"Retrieved {len(daily_tree)} items from 'daily' folder")
    return daily_tree


def normalize_date(date_str, format):
    try:
        parsed_date = datetime.strptime(date_str, format)
        return parsed_date.strftime("%Y-%m-%d")
    except ValueError:
        return None
```

## File: apps/market_data/views.py
```python
import requests
from rest_framework.response import Response
from rest_framework.decorators import api_view, authentication_classes, permission_classes
from rest_framework.permissions import AllowAny
from .models import StockData
from .utils import prepare_dict,prepare_list
import os
from dotenv import load_dotenv
from .serializers import StockDataSerializer
from django.contrib.postgres.search import  TrigramSimilarity
from django.db.models import Q,  FloatField
from django.db.models.functions import  Greatest, Coalesce

@api_view(['GET'])
@authentication_classes([])
@permission_classes([AllowAny])
def search(request):
    query = request.GET.get('q', '').strip()
    if not query:
        return Response({"error": "invalid query"}, status=400)

    stock_list = StockData.objects.annotate(
        symbol_similarity=TrigramSimilarity('symbol', query),
        stock_name_similarity=TrigramSimilarity('stock_name', query),

        max_similarity=Greatest(
            Coalesce('symbol_similarity', 0.0, output_field=FloatField()),
            Coalesce('stock_name_similarity', 0.0, output_field=FloatField())
        )
    ).filter(
        Q(symbol_similarity__gt=0.3) | Q(stock_name_similarity__gt=0.3)
    ).order_by(
        '-max_similarity',  
        '-symbol_similarity', '-stock_name_similarity' 
    )

    serializer = StockDataSerializer(stock_list, many=True)
    return Response(serializer.data)


@api_view(['GET'])
@authentication_classes([])
@permission_classes([AllowAny])
def fetch_and_store_stock_data(request):
    try:
        load_dotenv()
        nse_dict = prepare_dict(os.getenv('names_url'), "SYMBOL", "NAME OF COMPANY", " DATE OF LISTING", "%d-%b-%Y")
        etf_dict = prepare_dict(os.getenv('etf_url'), "Symbol", "SecurityName", "DateofListing", "%d-%b-%y")

        print(os.getenv('url'))
        data = prepare_list(os.getenv('url'))

        for item in data:
            name = item.get("path", "")
            if "_" not in name:  
                source_file = name
                symbol = name.replace(".csv", "").upper() 

                stock_name,start_date = nse_dict.get(symbol,("",None)) 
                isEtf=False
                if not stock_name:
                    stock_name,start_date = etf_dict.get(symbol,("",None)) 
                    isEtf = True if stock_name!="" else False

                stock_data = {
                    "symbol": symbol,
                    "source_file": source_file,
                    "start_date": start_date,
                    "latest_date": None,
                    "stock_name": stock_name,
                    "isEtf": isEtf,                   
                }

                serializer = StockDataSerializer(data=stock_data)

                if serializer.is_valid():
                    serializer.save()
                
            else:
                print(f"Skipping file with underscore: {name}")

        return Response({"message": "Stock data processed and stored successfully."}, status=200)

    except requests.exceptions.RequestException as e:
        return Response({"error": f"Failed to fetch data: {str(e)}"}, status=500)

    except Exception as e:
        return Response({"error": f"An unexpected error occurred: {str(e)}"}, status=500)
```

## File: apps/strategy/migrations/0001_initial.py
```python
# Generated by Django 5.1.4 on 2025-01-22 04:00

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='TemplateStrategy',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('title', models.CharField(max_length=255)),
                ('description', models.TextField(blank=True, null=True)),
                ('code', models.TextField()),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateField(auto_now=True)),
                ('tags', models.CharField(blank=True, max_length=100, null=True)),
            ],
            options={
                'abstract': False,
            },
        ),
        migrations.CreateModel(
            name='UserStrategy',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('title', models.CharField(max_length=255)),
                ('description', models.TextField(blank=True, null=True)),
                ('code', models.TextField()),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateField(auto_now=True)),
                ('author', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='user_strategies', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'abstract': False,
            },
        ),
    ]
```

## File: apps/strategy/admin.py
```python
from django.contrib import admin

# Register your models here.
```

## File: apps/strategy/apps.py
```python
from django.apps import AppConfig


class StrategyConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.strategy'
```

## File: apps/strategy/models.py
```python
from django.db import models
from django.contrib.auth import get_user_model

# Create your models here
User = get_user_model()

class BaseStrategy(models.Model):
    title = models.CharField(max_length=255)
    description = models.TextField(blank=True,null=True)
    code = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateField(auto_now=True)

    class Meta:
        abstract = True

    def __str__(self):
        return self.title
    

class UserStrategy(BaseStrategy):
    author = models.ForeignKey(User, on_delete=models.CASCADE,related_name='user_strategies')

class TemplateStrategy(BaseStrategy):
    tags = models.CharField(max_length=100, blank=True,null=True)
```

## File: apps/strategy/serializers.py
```python
from rest_framework import serializers
from .models import UserStrategy , TemplateStrategy

class BaseModelSerializer(serializers.ModelSerializer):
    class Meta:
        fields = ['id' , 'title', 'description', 'code' , 'created_at', 'updated_at']
        abstract = True

class UserSerializer(BaseModelSerializer):
    authors = serializers.StringRelatedField()

    class Meta(BaseModelSerializer.Meta):
        model = UserStrategy
        fields = BaseModelSerializer.Meta.fields + ['author']


class TemplateSerializer(BaseModelSerializer):
    class Meta(BaseModelSerializer.Meta):
        model = TemplateStrategy
        fields = BaseModelSerializer.Meta.fields + ['tags']
```

## File: apps/strategy/tests.py
```python
from django.test import TestCase

# Create your tests here.
```

## File: apps/strategy/urls.py
```python
from django.urls import path
from . import views

urlpatterns = [
    # admin only add template
    path('add/template/', views.AddTemplateView.as_view(), name='add-template'),
    
    # add or update user startegy
    path('add/', views.AddOrUpdateUserStrategyView.as_view(), name='add-or-update-strategy'),
    
    # get user strategy
    path('retrieve/', views.GetUserStrategiesView.as_view(), name='get-strategies'),
    
    # get user strategy by id
    path('retrieve/<int:pk>/', views.GetUserStrategyByIdView.as_view(), name='get-strategy'),
    
    # get all templates publix
    path('templates/', views.GetTemplateStrategiesView.as_view(), name='get-templates'),
    
    # get template by id (public)
    path('template/<int:pk>/', views.GetTemplateStrategyByIdView.as_view(), name='get-template'),
    
    # delete user start
    path('delete/<int:pk>/', views.DeleteUserStrategyView.as_view(), name='delete-strategy'),
]
```

## File: apps/strategy/views.py
```python
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status, permissions
from .serializers import UserSerializer, TemplateSerializer
from .models import UserStrategy, TemplateStrategy

class isAdmin(permissions.BasePermission):
    def has_permission(self, request, view):
        return request.user and request.user.is_staff
    
class AddTemplateView(APIView):
    permission_classes = [isAdmin]

    def post(self, request):
        serializer = TemplateSerializer(data=request.data) 
        if serializer.is_valid():
            serializer.save()
            return Response({"message": "Successfully added template"}, status=status.HTTP_201_CREATED)
        return Response({"message": "Error adding template"}, status=status.HTTP_400_BAD_REQUEST)

class AddOrUpdateUserStrategyView(APIView):
    def post(self, request):
        title = request.data.get("title")
        if not title:
            return Response({"error": "Title Required"}, status=status.HTTP_400_BAD_REQUEST)
        
        try:
            strategy = UserStrategy.objects.get(title=title, author=request.user)
            serializer = UserSerializer(strategy, data=request.data, partial=True)
        except UserStrategy.DoesNotExist:
            serializer = UserSerializer(data=request.data)
        
        if serializer.is_valid():
            serializer.save(author=request.user)
            status_code = status.HTTP_200_OK if strategy else status.HTTP_201_CREATED
            return Response(serializer.data, status=status_code)
        return Response({"message": "Error adding strategy"}, status=status.HTTP_400_BAD_REQUEST)
    
class GetUserStrategiesView(APIView):
    def get(self, request):
        strategies = UserStrategy.objects.filter(author=request.user).order_by('-updated_at')
        serializer = UserSerializer(strategies, many=True)
        return Response(serializer.data)
    
class GetUserStrategyByIdView(APIView):
    def get(self, request, pk):
        try:
            strategy = UserStrategy.objects.get(id=pk, author=request.user)
            serializer = UserSerializer(strategy)  
            return Response(serializer.data)
        except UserStrategy.DoesNotExist:
            return Response({"error": "Strategy Doesn't Exist"}, status=status.HTTP_404_NOT_FOUND)
        
class GetTemplateStrategiesView(APIView):
    authentication_classes = []  # public
    permission_classes = [permissions.AllowAny]

    def get(self, request):
        templates = TemplateStrategy.objects.all()
        serializer = TemplateSerializer(templates, many=True)
        return Response(serializer.data, status=status.HTTP_200_OK)
    
class GetTemplateStrategyByIdView(APIView):
    authentication_classes = []  # public
    permission_classes = [permissions.AllowAny]

    def get(self, request, pk):
        try:
            template = TemplateStrategy.objects.get(id=pk)
            serializer = TemplateSerializer(template)
            return Response(serializer.data)
        except TemplateStrategy.DoesNotExist:
            return Response({"error": "Template not found"}, status=status.HTTP_404_NOT_FOUND)
        
class DeleteUserStrategyView(APIView):
    def delete(self, request, pk):
        try:
            strategy = UserStrategy.objects.get(id=pk, author=request.user)
            strategy.delete()
            return Response(status=status.HTTP_204_NO_CONTENT)
        except UserStrategy.DoesNotExist:
            return Response({"error": "Strategy not found"}, status=status.HTTP_404_NOT_FOUND)
```

## File: apps/Authentication.py
```python
from rest_framework.authentication import BaseAuthentication
from rest_framework.exceptions import AuthenticationFailed
import jwt
from django.conf import settings
from django.contrib.auth import get_user_model
from google.oauth2 import id_token
from google.auth.transport import requests

User = get_user_model()

class SessionTokenAuthentication(BaseAuthentication):
    def authenticate(self, request):
        auth_header = request.headers.get('Authorization')
        if not auth_header or not auth_header.startswith('Bearer '):
            return None

        token = auth_header.split(' ')[1]

        try:
            idinfo = id_token.verify_oauth2_token(
                token, 
                requests.Request(), 
                settings.GOOGLE_CLIENT_ID
            )
            email = idinfo.get('email')
            if not email:
                raise AuthenticationFailed('Email not found in token')

            user = User.objects.get(email=email)
            return (user, None)

        except ValueError as e:
            print(f"Google token verification failed: {e}")
            raise AuthenticationFailed('Invalid token')
        except User.DoesNotExist:
            raise AuthenticationFailed('User not found')
        except Exception as e:
            print(f"Unexpected error: {e}")
            raise AuthenticationFailed('Authentication failed')
```

## File: config/asgi.py
```python
"""
ASGI config for config project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.1/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')

application = get_asgi_application()
```

## File: config/celery.py
```python
import os
import time
import logging
from celery import Celery

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = Celery('backdrop')

class CeleryConfig:
    broker_url = os.getenv('CELERY_BROKER_URL', 'redis://redis:6379/0')
    result_backend = os.getenv('CELERY_RESULT_BACKEND', 'redis://redis:6379/0')
    
    task_time_limit = 300
    task_soft_time_limit = 240
    task_acks_late = True
    task_reject_on_worker_lost = True
    task_default_retry_delay = 5
    task_max_retries = 3
    worker_send_task_events = True
    task_send_sent_event = True
    worker_concurrency = int(os.getenv('CELERY_WORKER_CONCURRENCY', '2'))

    task_routes = {
        'apps.engine.tasks.execute_code_task': {'queue': 'execution_queue'},
    }

    imports = (
        'apps.engine.tasks',
    )

app.config_from_object(CeleryConfig)

if os.getenv('USE_DJANGO', 'true').lower() == 'true':
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')
    app.autodiscover_tasks()

@app.on_after_configure.connect
def retry_broker_connection(sender, **kwargs):
    max_retries = 5
    retry_delay = 1
    
    for i in range(max_retries):
        try:
            sender.connection()
            logger.info("Successfully connected to broker")
            break
        except Exception as e:
            if i == max_retries - 1:
                logger.error(f"Failed to connect after {max_retries} attempts")
                raise
            logger.warning(f"Connection attempt {i + 1} failed, retrying in {retry_delay} seconds...")
            time.sleep(retry_delay)
            retry_delay *= 2

@app.task(bind=True, ignore_result=True)
def debug_task(self):
    logger.info(f'Request: {self.request!r}')
```

## File: config/settings.py
```python
"""
Django settings for config project.

Generated by 'django-admin startproject' using Django 5.1.4.

For more information on this file, see
https://docs.djangoproject.com/en/5.1/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.1/ref/settings/
"""

from pathlib import Path
import os
from dotenv import load_dotenv
from datetime import timedelta

load_dotenv()

DEBUG = os.getenv('url', '3000')
print("DEBUG:", DEBUG)

GOOGLE_CLIENT_ID = os.getenv('GOOGLE_CLIENT_ID')
NEXTAUTH_SECRET = os.getenv('NEXTAUTH_SECRET')


# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.1/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure-d5kl+gbu9=n4@-h-r1!#$g10*qw_&o@igum7ypyt_0441+z@k9'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = []


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'rest_framework',
    'rest_framework_simplejwt',
    'corsheaders',


    'apps.market_data',
    'apps.authorization.apps.AuthorizationConfig',
    'apps.strategy.apps.StrategyConfig',
    'apps.engine.apps.EngineConfig'
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

CORS_ALLOWED_ORIGINS = [
    "http://localhost:3001",  
    "https://yourfrontenddomain.com", 
    "http://localhost:3000",
    "http://localhost:3002",
]

CORS_ALLOW_CREDENTIALS = True

ROOT_URLCONF = 'config.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'config.wsgi.application'

# Database
# https://docs.djangoproject.com/en/5.1/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': os.getenv('POSTGRES_DB', 'postgres'),
        'USER': os.getenv('POSTGRES_USER', 'postgres'),
        'PASSWORD': os.getenv('POSTGRES_PASSWORD', 'postgres'),
        'HOST': os.getenv('POSTGRES_HOST', 'postgres'),
        'PORT': os.getenv('POSTGRES_PORT', '5432')
    }
}

AUTH_USER_MODEL = 'authorization.User'

# SECRET_KEY=config('SECRET_KEY')

REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'apps.Authentication.SessionTokenAuthentication',  
        'rest_framework.authentication.SessionAuthentication',
        'rest_framework.authentication.BasicAuthentication',
    ],
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated',
    ],
}

CACHES = {
    'default': {
        'BACKEND': 'django_redis.cache.RedisCache',
        'LOCATION': 'redis://127.0.0.1:6379/1',  
        'OPTIONS': {
            'CLIENT_CLASS': 'django_redis.client.DefaultClient',
        }
    }
}


SIMPLE_JWT = {
    'ACCESS_TOKEN_LIFETIME': timedelta(days=1),
    'REFRESH_TOKEN_LIFETIME': timedelta(days=7),
    'ROTATE_REFRESH_TOKENS': True,  
    'BLACKLIST_AFTER_ROTATION': True,  
}

# Password validation
# https://docs.djangoproject.com/en/5.1/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.1/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.1/howto/static-files/

STATIC_URL = 'static/'

# Default primary key field type
# https://docs.djangoproject.com/en/5.1/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

CELERY_BROKER_URL = 'redis://redis:6379/0'
CELERY_RESULT_BACKEND = 'redis://redis:6379/0'
CELERY_ACCEPT_CONTENT = ['json']
CELERY_TASK_SERIALIZER = 'json'
CELERY_RESULT_SERIALIZER = 'json'
CELERY_TIMEZONE = 'UTC'
CELERY_TASK_TRACK_STARTED = True
CELERY_TASK_TIME_LIMIT = 30 * 60
CELERY_REDIS_MAX_CONNECTIONS = 20
CELERY_BROKER_CONNECTION_RETRY = True
CELERY_BROKER_CONNECTION_RETRY_ON_STARTUP = True
CELERY_BROKER_CONNECTION_MAX_RETRIES = 10
CELERY_BROKER_POOL_LIMIT = 10
CELERY_REDIS_SOCKET_TIMEOUT = 5
CELERY_REDIS_SOCKET_CONNECT_TIMEOUT = 5

ALLOWED_BUILTINS = [
    'abs', 'bool', 'dict', 'float', 'int', 'len',
    'list', 'max', 'min', 'range', 'round', 'str',
    'sum', 'tuple', 'type'
]

LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
        },
    },
    'loggers': {
        'apps.engine.tasks': {
            'handlers': ['console'],
            'level': 'DEBUG',  # Set to DEBUG to see debug logs
            'propagate': True,
        },
    },
}
```

## File: config/urls.py
```python
"""
URL configuration for config project.

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/5.1/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path,include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('data/',include("apps.market_data.urls")),
    path('auth/',include("apps.authorization.urls")),
    path('strategy/',include("apps.strategy.urls")),
    path('engine/',include("apps.engine.urls"))
]
```

## File: config/wsgi.py
```python
"""
WSGI config for config project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.1/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')

application = get_wsgi_application()
```

## File: docker/sandbox/Dockerfile
```
FROM python:3.10-slim AS builder

WORKDIR /app
RUN apt-get update && \
    apt-get install -y --no-install-recommends gcc python3-dev && \
    rm -rf /var/lib/apt/lists/*

RUN pip install --no-cache-dir pandas

FROM python:3.10-slim
WORKDIR /app

COPY --from=builder /usr/local/lib/python3.10/site-packages /usr/local/lib/python3.10/site-packages
COPY --from=builder /usr/local/bin /usr/local/bin

RUN apt-get update && \
    apt-get install -y --no-install-recommends procps && \
    rm -rf /var/lib/apt/lists/* && \
    useradd -m sandboxuser

USER sandboxuser
COPY execute.py .
CMD ["sleep", "infinity"]
```

## File: docker/sandbox/entrypoint.sh
```bash
#!/bin/sh
while true; do
    sleep 3600
done
```

## File: docker/sandbox/execute.py
```python
import os
import sys
import pickle
import pandas as pd
import numpy as np
import logging
import ast
import json

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[
        logging.StreamHandler(sys.stdout),
    ]
)

logger = logging.getLogger(__name__)

class SafeCodeVisitor(ast.NodeVisitor):
    def visit_Import(self, node):
        raise ValueError("Import statements are not allowed")
    def visit_ImportFrom(self, node):
        raise ValueError("Import statements are not allowed")
    def visit_Call(self, node):
        if isinstance(node.func, ast.Name) and node.func.id in {"exec", "eval", "open"}:
            raise ValueError(f"Call to '{node.func.id}' is not allowed")
        self.generic_visit(node)

def validate_user_code(code):
    tree = ast.parse(code)
    SafeCodeVisitor().visit(tree)

def load_data():
    try:
        
        code_path = '/host_tmpfs/code.py'  
        data_path = '/host_tmpfs/data.pkl'  

        logger.info(f"Contents of /host_tmpfs: {os.listdir('/host_tmpfs')}")

        if not os.path.exists(code_path):
            logger.error(f"Code file not found: {code_path}")
            sys.exit(2)
        if not os.path.exists(data_path):
            logger.error(f"Data file not found: {data_path}")
            sys.exit(2)

        with open(code_path, 'r') as code_file:
            code = code_file.read()
            logger.info(f"Successfully read code from {code_path}")

        with open(data_path, 'rb') as data_file:
            df = pickle.load(data_file) 
            logger.info(f"Successfully read data from {data_path}")

        return code, df
    except Exception as e:
        logger.error(f"Data loading error: {str(e)}")
        sys.exit(2)

if __name__ == "__main__":
    try:
        logger.info("Starting execution of backtest code")
        code, df = load_data()

        try:
            validate_user_code(code)
        except ValueError as e:
            print(f"Invalid user code: {e}")
            raise
        
        local_env = {
            "pd": pd, 
            "np": np  
        }   

        logger.info("Executing user-provided code")
        exec(code,None, local_env)
        
        if 'run_backtest' not in local_env or not callable(local_env['run_backtest']):
            raise ValueError("No valid 'run_backtest' function defined")

        logger.info("Running backtest function")
        execution_result = local_env['run_backtest'](df)

        result = None

        if isinstance(execution_result, pd.DataFrame):
            result = execution_result.to_json(orient="records")
        else:
            result  = json.dumps(execution_result)
        
        sys.stdout.write(json.dumps(result))
        sys.stdout.flush()
    except Exception as e:
        logger.error(f"Execution error: {str(e)}")
        sys.exit(1)
```

## File: docker/sandbox/requirements.txt
```
redis==5.0.1
numpy==1.26.3
pandas==2.1.4
psutil==5.9.7
```

## File: .dockerignore
```
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# Virtual Environment
venv/
ENV/

# IDE
.idea/
.vscode/

# Docker
docker/
worker/
Dockerfile*
docker-compose*.yml

# Git
.git/
.gitignore

# Local development
*.env
*.log
*.sqlite3
media/
static/
tmp/
```

## File: .env.example
```
POSTGRES_USER=postgres
POSTGRES_PASSWORD=postgres
POSTGRES_DB=postgres
POSTGRES_HOST=localhost
POSTGRES_PORT=5432

CELERY_BROKER_URL=redis://localhost:6379/0
CELERY_RESULT_BACKEND=redis://localhost:6379/0

url="https://api.github.com/repos/BennyThadikaran/eod2_data"
names_url ="https://raw.githubusercontent.com/muneerahmed03/store/main/nse_names.csv"
etf_url ="https://raw.githubusercontent.com/muneerahmed03/store/main/etf.csv"

GOOGLE_CLIENT_ID=

NEXTAUTH_SECRET=
```

## File: .gitignore
```
# Python
*.pyc
*.pyo
__pycache__/

# Virtual Environment
.venv/
venv/

# Django
*.log
db.sqlite3
media/
staticfiles/

# Environment variables
.env
```

## File: entrypoint.sh
```bash
#!/bin/sh
set -e

echo "Starting Docker daemon..."
dockerd > /var/log/dockerd.log 2>&1 &


echo "Waiting for Docker daemon to start..."
while ! docker info >/dev/null 2>&1; do
  sleep 1
done
echo "Docker daemon started."

DOCKER_GID=$(stat -c '%g' /var/run/docker.sock)

EXISTING_GROUP=$(getent group $DOCKER_GID | cut -d: -f1)

if [ -z "$EXISTING_GROUP" ]; then
  echo "Creating new group with GID ${DOCKER_GID}..."
  addgroup --gid $DOCKER_GID docker_host_group
  EXISTING_GROUP="docker_host_group"
fi

echo "Adding appuser to group ${EXISTING_GROUP}..."
adduser appuser $EXISTING_GROUP

echo "Starting Celery worker as appuser..."
exec gosu appuser "$@"
```

## File: manage.py
```python
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()
```

## File: README.md
```markdown
# Build the image without starting services
docker-compose build sandbox

# Start all services EXCEPT sandbox
docker-compose up -d postgres redis celery_worker web


RUNTIME_CELERY=true celery -A config.celery:app worker -l info -Q execution_queue
```

## File: requirements.txt
```
amqp==5.3.1
asgiref==3.8.1
async-timeout==5.0.1
billiard==4.2.1
cachetools==5.5.0
celery==5.4.0
certifi==2024.12.14
charset-normalizer==3.4.1
click==8.1.8
click-didyoumean==0.3.1
click-plugins==1.1.1
click-repl==0.3.0
Django==5.1.4
django-cors-headers==4.6.0
djangorestframework==3.15.2
djangorestframework_simplejwt==5.4.0
docker==7.1.0
google-auth==2.37.0
google-auth-oauthlib==1.2.1
idna==3.10
kombu==5.4.2
numpy==2.2.2
oauthlib==3.2.2
pandas==2.2.3
prompt_toolkit==3.0.50
psycopg2-binary==2.9.10
pyasn1==0.6.1
pyasn1_modules==0.4.1
PyJWT==2.10.1
python-dateutil==2.9.0.post0
python-decouple==3.8
python-dotenv==1.0.1
pytz==2024.2
redis==5.2.1
requests==2.32.3
requests-oauthlib==2.0.0
rsa==4.9
six==1.17.0
sqlparse==0.5.3
typing_extensions==4.12.2
tzdata==2025.1
urllib3==2.3.0
vine==5.1.0
wcwidth==0.2.13
```
